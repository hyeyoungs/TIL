# 컨벤션
## 이름
### Java 표기법
일반적으로 이렇게 함
- 변수 이름 : camelCase
- 함수 이름 : camelCase
- 클래스 이름 : PascalCase
- 패키지 이름 : allowercase
- 상수 : UPPER_SNAKE_CASE

<br>

### 축약어
축약어를 대문자로 표현하지 않고 일반 명사와 같은 취급
- private String userID (X)
- private String userId (O)

<br>

## 동사
### get vs find
- get : return Type이 T인 경우 (일반적으로 데이터가 없을 시 exception을 thorw 함)
- find : return Type이 Optional<T>인 경우

<br>

### isExist vs exist
exist를 사용

<br>

### get
get을 남발하지 않음

get 접두어는 갖고 있는 속성 정보를 제공한다는 의미

<br>

## 롬복
### getter setter를 남발하지 않음
캡슐화를 망치는 주범

사실상 public 멤버 변수임

객체를 수동적이게 만듦 (객체가 데이터 저장과 보여주는 일만 함)
```Java
class UserManager {
  public void doSomething(User user) {
    user.setStatus(Status.ACTIVE);
    user.setLastLoginTimestamp(Clock.systemUTC().millis());
  }
}
```
객체를 능동적으로 만들자
```Java
class UserManager {
  public void doSomething(User user) {
    user.inactive();
    user.login(Clock.systemUTC());
  }
}
```

<br>

## 가독성
### 주석
주석은 정말 필요할 때만 사용

읽기 좋은 코드는 그 자체만으로 잘 읽힘

주석 달고 싶다 → 메서드를 분리하라는 신호

<br>

### Collection.Map
Collection.Map을 남발하지 마라

가급적이면 일급 클래스로 만들고 사용하더라도 지정된 {scope} 밖을 넘나들지 마라

📚 유익한 자료 : [일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)

<br><br>

# 객체
## 객체의 종류
### 생성자의 역할
생성자는 가급적 두개의 역할만 해야함
- 값을 검증
- 값을 할당

<br>

### Entity
- 유일한 식별자가 있고,
- 수명 주기가 있으며,
- 쓰기 모델 저장소에 저장함으로써 지속성을 가지며 나중에 저장소에 불러올 수 있음

<br>

### 객체를 만들 때의 고민
- 어떤 값을 불변으로 만들 것인가?
- 어떤 인터페이스를 노출할 것인가?

<br>

## 디미터 법칙
- 모듈은 자신이 조작하는 개체의 속사정을 몰라야 함

<br>

## 행동
- 자동차는 바퀴, 프레임, 엔진, 방향, 속도 값들을 갖고 있어야겠다.
```Java
class Car {
  private Frame frame;
  private Engine engine;
  private List<Wheel> wheels;
  private Direction direction;
  private Speed speed;
}
```
- 자동차는 달릴 수 있어야 하고, 속도를 조절할 수 있어야 하고, 방향을 바꿀 수 있어야 해.
```Java
class Car {
  public void drive() {}
  public void changeDirection() {}
  public void accelrate(Speed speed) {}
  public void decelerate(Speed speed) {}
}
```

데이터 위주의 사고 < 행동 위주의 사고

- duck typing : 행동이 같다면 같은 클래스로 부르겠다.

<br>

## 순환 참조
### 순환 참조, 양방향 참조를 만들지 마라
- 순환 의존성 자체가 결합도를 높이는 원인이 됨 (순환 의존성이라는 말은 그 2개는 하나의 클래스여야 한다는 의미이기 때문)
- 순환 참조 때문에 Serialize가 불가해짐

<br>

### 간접 참조로 해결
```Java
Class User {
  private String id;
  private String username;
  private List<Feed> feeds;
}

Class Feed {
  private long id;
  private String content;
  private long writerId; // 차라리 Id로 필요할 때마다 찾아오는게 나음
}
```

<br>

### 컴포넌트 분리
- mappedby를 고민할 필요가 없음
<img width="700" alt="스크린샷 2024-01-07 오후 10 45 43" src="https://github.com/hyeyoungs/TIL/assets/29566893/4c954058-fe8f-40da-b245-368b382ec989">

<br><br>

# 설계
## SOLID
### Single response
모든 클래스는 하나의 책임만 가지며, 어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 함
> 코드 라인이 100줄 이상이라면 의심해봐야 함

<br>

### Open-Closed
기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능함
> 🤔 추상화(인터페이스화)가 부족한 경우 

<br>

### Liskov substitution
> 🤔 상위 클래스와 하위 클래스 사이의 계약이 깨지는 경우 

<br>

### Interface-Segregation
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 함
> 🤔 인터페이스를 분리해서 조립하듯이 개발하지 않을 경우 

<br> 

### Dependency inversion
세부사항이 추상화에 의존해야 함
> 🤔 구현체에 바로 의존할 경우 문제가 발생 

<br>

## 의존성
### 의존성이란?
> Dependency or coupling, a state in which one object uses a fuction of another object
> <br>🤔 A는 B를 사용하기만 해도 A는 B에 의존한다 할 수 있음
``` Java
class Chef {
  public Hamburger makeHamburger() { // Hamburger는 Bread, Meat, Lettuce, Source 의존함
    Bread bread = new Bread();
    Meat meat = new Meat();
    Lettuce lettuce = new Lettuce();
    Source source = new Source();
    return Hamburger.builder()
                    .bread(bread)
                    .meat(meat)
                    .lettuce(lettuce)
                    .source(source)
                    .build();
  }
}
```

<br>

### 의존성 주입(DI)이란?
필요한 값을 의존성에 넣어주면 의존성 주입 
#### 1. 파라미터 주입
``` Java
class Chef {
  public Hamburger makeHamburger(
            Bread bread,
            Meat meat,
            Lettuce lettuce,
            Source source) {
      return Hamburger.builder()
                    .bread(bread)
                    .meat(meat)
                    .lettuce(lettuce)
                    .source(source)
                    .build();
  }
}
```
#### 2. 필드 주입
``` Java
@Setter
class Chef {
  public Hamburger makeHamburger(
    Bread bread;
    Meat meat;
    Lettuce lettuce;
    Source source;

    public Hamburger makeHamburger() {
      return Hamburger.builder()
                      .bread(bread)
                      .meat(meat)
                      .lettuce(lettuce)
                      .source(source)
                      .build();
  }
}
``` 
#### 3. 생성자 주입
``` Java
class Chef {
  private final Bread bread;
  private final Meat meat;
  private final Lettuce lettuce;
  private final Source source;

  public Chef(Bread bread, Meat meat, Lettuce lettuce, Source source) {
    this.bread = bread;
    this.meat = meat;
    this.lettuce = lettuce;
    this.source = source;
  }

    public Hamburger makeHamburger() {
      return Hamburger.builder()
                      .bread(bread)
                      .meat(meat)
                      .lettuce(lettuce)
                      .source(source)
                      .build();
  }
}
``` 

<br>

### 의존성 주입과 오해
#### 의존성이 사라진게 아니라 약해진 것
#### Dependency Injection과 Dependency Inversion은 다름
> Dependency Injection은 의존성 주입 (DI)
> Dependency Inversion은 의존성 역전 (SOLID-DP)

<br>
