# 컨벤션
## 이름
### Java 표기법
일반적으로 이렇게 함
- 변수 이름 : camelCase
- 함수 이름 : camelCase
- 클래스 이름 : PascalCase
- 패키지 이름 : allowercase
- 상수 : UPPER_SNAKE_CASE

<br>

### 축약어
축약어를 대문자로 표현하지 않고 일반 명사와 같은 취급
- private String userID (X)
- private String userId (O)

<br>

## 동사
### get vs find
- get : return Type이 T인 경우 (일반적으로 데이터가 없을 시 exception을 thorw 함)
- find : return Type이 Optional<T>인 경우

<br>

### isExist vs exist
exist를 사용

<br>

### get
get을 남발하지 않음

get 접두어는 갖고 있는 속성 정보를 제공한다는 의미

<br>

## 롬복
### getter setter를 남발하지 않음
캡슐화를 망치는 주범

사실상 public 멤버 변수임

객체를 수동적이게 만듦 (객체가 데이터 저장과 보여주는 일만 함)
```Java
class UserManager {
  public void doSomething(User user) {
    user.setStatus(Status.ACTIVE);
    user.setLastLoginTimestamp(Clock.systemUTC().millis());
  }
}
```
객체를 능동적으로 만들자
```Java
class UserManager {
  public void doSomething(User user) {
    user.inactive();
    user.login(Clock.systemUTC());
  }
}
```

<br>

## 가독성
### 주석
주석은 정말 필요할 때만 사용

읽기 좋은 코드는 그 자체만으로 잘 읽힘

주석 달고 싶다 → 메서드를 분리하라는 신호

<br>

### Collection.Map
Collection.Map을 남발하지 마라

가급적이면 일급 클래스로 만들고 사용하더라도 지정된 {scope} 밖을 넘나들지 마라

📚 유익한 자료 : [일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)

<br><br>

# 객체
## 객체의 종류
### 생성자의 역할
생성자는 가급적 두개의 역할만 해야함
- 값을 검증
- 값을 할당

<br>

### Entity
- 유일한 식별자가 있고,
- 수명 주기가 있으며,
- 쓰기 모델 저장소에 저장함으로써 지속성을 가지며 나중에 저장소에 불러올 수 있음

<br>

### 객체를 만들 때의 고민
- 어떤 값을 불변으로 만들 것인가?
- 어떤 인터페이스를 노출할 것인가?

<br>

## 디미터 법칙
- 모듈은 자신이 조작하는 개체의 속사정을 몰라야 함

<br>

## 행동
- 자동차는 바퀴, 프레임, 엔진, 방향, 속도 값들을 갖고 있어야겠다.
```Java
class Car {
  private Frame frame;
  private Engine engine;
  private List<Wheel> wheels;
  private Direction direction;
  private Speed speed;
}
```
- 자동차는 달릴 수 있어야 하고, 속도를 조절할 수 있어야 하고, 방향을 바꿀 수 있어야 해.
```Java
class Car {
  public void drive() {}
  public void changeDirection() {}
  public void accelrate(Speed speed) {}
  public void decelerate(Speed speed) {}
}
```

데이터 위주의 사고 < 행동 위주의 사고

- duck typing : 행동이 같다면 같은 클래스로 부르겠다.

<br>

## 순환 참조
### 순환 참조, 양방향 참조를 만들지 마라
- 순환 의존성 자체가 결합도를 높이는 원인이 됨 (순환 의존성이라는 말은 그 2개는 하나의 클래스여야 한다는 의미이기 때문)
- 순환 참조 때문에 Serialize가 불가해짐

<br>

### 간접 참조로 해결
```Java
Class User {
  private String id;
  private String username;
  private List<Feed> feeds;
}

Class Feed {
  private long id;
  private String content;
  private long writerId; // 차라리 Id로 필요할 때마다 찾아오는게 나음
}
```

<br>

### 컴포넌트 분리
- mappedby를 고민할 필요가 없음
<img width="700" alt="image" src="https://github.com/hyeyoungs/TIL/assets/29566893/890c3de5-7b42-4a5c-a163-b97d37f8b899">

<br><br>
